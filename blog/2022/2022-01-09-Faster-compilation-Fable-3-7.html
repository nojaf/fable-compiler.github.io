<html class="has-navbar-fixed-top" lang="en"><head><title>Fable · Faster compilations with Fable 3.7</title><meta http-equiv="content-type" content="text/html; charset=UTF-8" charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" type="text/css" href="/style.css"/><script src="https://unpkg.com/scroll-into-view-if-needed@2.2.28/umd/scroll-into-view-if-needed.min.js"></script></head><body><nav class="navbar is-fixed-top is-spaced"><div class="container"><div class="navbar-brand"><a class="navbar-item title is-4" href="https://fable.io/">Fable</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/docs">Documentation</a><a class="navbar-item is-hidden-mobile" href="/packages/">Packages</a><a class="navbar-item is-hidden-mobile" href="/repl/">Try</a><a class="navbar-item is-active" href="/blog/index.html">Blog</a><a class="navbar-item is-hidden-mobile" href="/community.html">Community</a><a class="navbar-item is-hidden-mobile" href="/resources.html">Resources</a><div class="navbar-item navbar-burger-dots is-hidden-tablet"><svg height="4" stroke="none" viewBox="0 0 22 4" width="22"><circle cx="2" cy="2" r="2"></circle><circle cx="2" cy="2" r="2" transform="translate(9,0)"></circle><circle cx="2" cy="2" r="2" transform="translate(18,0)"></circle></svg></div></div><div class="navbar-end is-hidden-mobile"><a class="navbar-item" href="https://github.com/fable-compiler/fable"><span class="icon"><i class=" fab fa-github fa-lg"></i></span></a><a class="navbar-item" href="https://twitter.com/FableCompiler"><span class="icon"><i class=" fab fa-twitter fa-lg"></i></span></a><a class="navbar-item" href="https://gitter.im/fable-compiler/Fable"><span class="icon"><i class=" fab fa-gitter fa-lg"></i></span></a><a class="navbar-item" href="https://www.youtube.com/channel/UC6m70Jyr65ogDySbK7aMmzg/videos"><span class="icon"><i class=" fab fa-youtube fa-lg"></i></span></a></div></div><div class="nacara-navbar-menu"><a class="nacara-navbar-menu-item" href="/packages/">Packages</a><a class="nacara-navbar-menu-item" href="/repl/">Try</a><a class="nacara-navbar-menu-item" href="/community.html">Community</a><a class="nacara-navbar-menu-item" href="/resources.html">Resources</a><a class="nacara-navbar-menu-item" href="https://github.com/fable-compiler/fable">Github</a><a class="nacara-navbar-menu-item" href="https://twitter.com/FableCompiler">Twitter</a><a class="nacara-navbar-menu-item" href="https://gitter.im/fable-compiler/Fable">Gitter</a><a class="nacara-navbar-menu-item" href="https://www.youtube.com/channel/UC6m70Jyr65ogDySbK7aMmzg/videos">Youtube</a></div></div></nav><div class="grey-overlay"></div><div class="nacara-content"><div class="container"><div class="columns"><div class="column is-8-desktop is-offset-2-desktop"><div class="section blog-post"><figure class="image is-96x96 author-image"><img class="is-rounded" src="https://github.com/alfonsogarciacaro.png"/></figure><h2 class="title is-size-3 has-text-primary has-text-weight-normal has-text-centered blog-title">Faster compilations with Fable 3.7</h2><div class="tags has-addons is-justify-content-center"><a class="tag is-rounded is-medium is-primary" href="https://twitter.com/alfonsogcnunez">Alfonso García-Caro</a><span class="tag is-rounded is-medium">January 9, 2022</span></div><div class="content"><style class=grvsc-styles>.grvsc-container{overflow:auto;position:relative;-webkit-overflow-scrolling:touch;padding-top:1rem;padding-top:var(--grvsc-padding-top,var(--grvsc-padding-v,1rem));padding-bottom:1rem;padding-bottom:var(--grvsc-padding-bottom,var(--grvsc-padding-v,1rem));border-radius:8px;border-radius:var(--grvsc-border-radius,8px);font-feature-settings:normal;line-height:1.4}.grvsc-code{display:table}.grvsc-line{display:table-row;box-sizing:border-box;width:100%;position:relative}.grvsc-line>*{position:relative}.grvsc-gutter-pad{display:table-cell;padding-left:.75rem;padding-left:calc(var(--grvsc-padding-left,var(--grvsc-padding-h,1.5rem))/ 2)}.grvsc-gutter{display:table-cell;-webkit-user-select:none;-moz-user-select:none;user-select:none}.grvsc-gutter::before{content:attr(data-content)}.grvsc-source{display:table-cell;padding-left:1.5rem;padding-left:var(--grvsc-padding-left,var(--grvsc-padding-h,1.5rem));padding-right:1.5rem;padding-right:var(--grvsc-padding-right,var(--grvsc-padding-h,1.5rem))}.grvsc-source:empty::after{content:' ';-webkit-user-select:none;-moz-user-select:none;user-select:none}.grvsc-gutter+.grvsc-source{padding-left:.75rem;padding-left:calc(var(--grvsc-padding-left,var(--grvsc-padding-h,1.5rem))/ 2)}.grvsc-has-line-highlighting>.grvsc-code>.grvsc-line::before{content:' ';position:absolute;width:100%}.grvsc-line-diff-add::before{background-color:var(--grvsc-line-diff-add-background-color,rgba(0,255,60,.2))}.grvsc-line-diff-del::before{background-color:var(--grvsc-line-diff-del-background-color,rgba(255,0,20,.2))}.grvsc-line-number{padding:0 2px;text-align:right;opacity:.7}.atom-one-light{background-color:#fafafa;color:#383a42}.atom-one-light .grvsc-line-highlighted::before{background-color:var(--grvsc-line-highlighted-background-color,rgba(0,0,0,.05));box-shadow:inset var(--grvsc-line-highlighted-border-width,4px) 0 0 0 var(--grvsc-line-highlighted-border-color,rgba(0,0,0,.2))}</style><p>Fable 3 brought <a href=https://fable.io/blog/2020/2020-10-23-Announcing-Nagareyama-1.html>nice speed improvements</a> to the compiler. Fable has also, since the beginning, put a lot of focus in watch compilations so you can see your changes reflected on screen almost immediately, as it happens in normal JS development workflows. However, I've been recently working in big projects where the times for the first compilation started to get too long: both in local development because bootstrapping a development server could take over a minute, and in CI, where compiling multiple Fable apps could take forever.<p>To improve the situation, we've been exploring all the optimization opportunities and we're now proud to present you Fable 3.7 with many new features to improve your build pipelines. Let's list them here:<h2 id=caching-fsproj-parsing-results>Caching .fsproj parsing results<a href=#caching-fsproj-parsing-results aria-hidden=true tabindex=-1><span class=anchor>#</span></a></h2><p>There's a part of Fable compilation that takes a sizeable portion of the total time but we haven't given enough attention until now: parsing <code>.fsproj</code> files (main project and references). Simple parsing is not enough most of the times, under the cover Fable has to invoke MSBuild to get the correct F# compiler options out of the <code>.fsproj</code> which can take several seconds. Seconds we can save by caching the project options and reuse them if the <code>.fsproj</code> file hasn't changed, and this is what Fable 3.7 does.<h2 id=ffable-compilation-inter-threading>F#/Fable compilation inter-threading<a href=#ffable-compilation-inter-threading aria-hidden=true tabindex=-1><span class=anchor>#</span></a></h2><p>On a high-level perspective there are three main steps in a Fable compilation: 1) Parsing the F# source files, 2) Type checking the parsed files, 3) Converting the checked files into JS. Phases 1 and 3 can be parallelized at the file level but 2, which tends to take most of the time, cannot be due to F# type-inference (remember that file order is important in F#?). So far, Fable was waiting until type checking was finished and during this time in multi-core machines, much of the CPU power was left unused. Since Fable 3.7 we've changed this so the F# compiler will report each type checked individually letting Fable start right away and take advantage of the unused CPU. In most cases, because the Fable compilation was faster than F# type checking, this means Fable-only compilation time (around 20-40% of the total) <a href=https://github.com/fable-compiler/Fable/pull/2676>disappears</a>!<h2 id=automatic---runfast>Automatic --runFast<a href=#automatic---runfast aria-hidden=true tabindex=-1><span class=anchor>#</span></a></h2><p><code>--runFast</code> is an option that has been present since Fable 3 release. It's used to trigger a development server right away instead of waiting until Fable compilation is finished. This is useful in watch mode because most of the times you already have generated JS files from a previous compilation, so the bundler/dev server can start working without waiting for Fable to finish. However we haven't really promoted this option because it can cause issues (e.g. when there are no JS files or when Fable overwrite them after the development server has started), so it has remained a "hidden" option that almost nobody uses.<p>In v3.7 Fable will automatically decide when to "run fast" the development server. Thanks to the stored cached info, Fable can decide if the JS files in disk were generated with the same compiler options and in that case fire up the dev server (like Webpack or Vite) and run a "silent" compilation. While you test the app in the browser, Fable will finish a first compilation in the background without overwriting the files so it keeps the results in memory and can react quickly when you make any change (as it was already happening in previous Fable versions).</p><br><p>Your mileage may, and will, vary, but with these optimizations combined we've seen compilation times (from the second time on, when the parsed <code>.fsproj</code> options are cached) improved by around 40% in some projects. And in watch compilations it will look as if compilation is instantaneous (it will actually be running in the background). If this is not enough for you, Fable 3.7 also includes a non-automatic feature that can give you a bigger boost. Keep reading.<h2 id=precompilation>Precompilation<a href=#precompilation aria-hidden=true tabindex=-1><span class=anchor>#</span></a></h2><p>As seen above, Fable needs to compile every source file including packages and references every time. There are several reasons for this:<ol><li><p>Unlike .NET which guarantees backwards compilation for <code>.dll</code>s, JS code generated by Fable is usually not be compatible with code generated by another compiler version, even for patch updates. We constantly change the JS representation of F# structures to fix bugs or improve performance.<li><p>Also unlike .NET, where packages are normally distributed in Release compilation mode. Fable packages can include extra code in Debug mode for analysis, etc, as it's normal to do in JS packages. Not only this, many packages use the <code>FABLE_COMPILER</code> constant to compile code differently depending on the platform (.NET or JS) but this is not included in the <code>.dll</code>. In most cases, signatures remain the same but in a few libraries like Fable.React they don't, which breaks contracts.<li><p>To compile calls to inlined functions, it's not enough to have the generated JS code, Fable needs access to the original F# code (in its type-checked AST form).</ol><p>Problems 1) and 2) still remain, which makes not possible to distribute Fable packages in compiled form. But after a big refactoring we've managed to solve 3) by serializing the inlined expressions. This has opened the possibility to precompile code locally, when we use the same compiler version and options. You can try it as follows (note we always need to specify an output directory in this case):<pre class="atom-one-light grvsc-container"data-index=0 data-language><code class=grvsc-code><span class=grvsc-line><span class=grvsc-source>dotnet fable precompile path/to/MyLib.fsproj -o build/myLib</span></span></code></pre><br><p>After the "normal" compilation, Fable will generate a <code>.dll</code> assembly and also serialize inline expressions and other information. Now when compiling your app you can tell Fable it can reuse those files. You do this with the <code>--precompiledLib</code> argument which should point to the build directory of the precompiled library.<pre class="atom-one-light grvsc-container"data-index=1 data-language><code class=grvsc-code><span class=grvsc-line><span class=grvsc-source>dotnet fable path/to/MyApp.fsproj --precompiledLib build/myLib</span></span></code></pre><br><p>Usually <code>MyApp.fsproj</code> will reference <code>MyLib.fsproj</code>. Fable will analyze which files can be reused and skip compilation for those. The performance improvement will be more or less proportional to the number of files you can precompile, so if you can precompile half of the files (including sources from packages) you should get around 50% faster compilations. In order to make sure the precompiled files are up-to-date, it's a good idea to always run the <code>precompile</code> command beforehand, Fable will automatically skip precompilation if files haven't changed. So your build script will look like:<pre class="atom-one-light grvsc-container"data-index=2 data-language><code class=grvsc-code><span class=grvsc-line><span class=grvsc-source>dotnet fable precompile path/to/MyLib.fsproj -o build/myLib</span></span>
<span class=grvsc-line><span class=grvsc-source>dotnet fable path/to/MyApp.fsproj --precompiledLib build/myLib</span></span></code></pre><br><p>Why not do this always automatically, at least for packages? Unfortunately there are also some drawbacks to precompilation:<ul><li>First compilation (or whenever there's a change in precompiled files) will take longer because of the <code>.dll</code> generation (hopefully this will <a href=https://github.com/dotnet/fsharp/pull/12334#issuecomment-1001100351>improve soon</a>) and inline expression serialization<li>Precompiled files won't be watched<li>Some Fable packages will produce compiler errors when generating a <code>.dll</code> assembly using <code>FABLE_COMPILER</code> constant</ul><p>Because of this, for now we've decided to make this feature an opt-in and gather feedback from users. It's recommended to use precompilation when you have a big project with an internal library that changes less often, or when you have multiple apps that reference a common library.<hr><p>At the time of writing Fable 3.7 is still released as beta. This is in case we still need to make some small adjustment to the precompilation feature after getting feedback, but the release has already been tested with projects in production and there won't be big changes after this point. So I encourage you to to try it out, enjoy the benefits of faster compilations and report any glitch you encounter or suggestions you may have. Just remember to specify the version range when updating:<pre class="atom-one-light grvsc-container"data-index=3 data-language><code class=grvsc-code><span class=grvsc-line><span class=grvsc-source>dotnet tool update fable --version 3.7.0-beta-*</span></span></code></pre><br><p>And on another note, v3.7 will be the last minor release for the Fable 3 cycle. From now on we will focus on <em>Beyond</em>: the codename for the next Fable major release which will take F# not only beyond .NET, but also beyond JS and into the realms of Python, Rust and more. 2022 is bound to be an exciting year for F# and Fable developers, Happy New Year!</div></div></div></div></div></div><script async="" src="/resources/nacara-standard-layouts/scripts/menu.js"></script></body></html>